'use strict';

exports.__esModule = true;

var _Config2 = require('./Config');

var _Config3 = _interopRequireDefault(_Config2);

var _constants = require('../constants');

var _utils = require('../utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } // classes


// constants


// utils


/**
 * @module classes/ChartConfig
 */

var isArray = Array.isArray;

/**
 * @private
 *
 * @class ChartConfig
 * @classdesc configuration object builder for charts
 */

var ChartConfig = function (_Config) {
  _inherits(ChartConfig, _Config);

  function ChartConfig() {
    _classCallCheck(this, ChartConfig);

    return _possibleConstructorReturn(this, _Config.apply(this, arguments));
  }

  /**
   * @function addType
   *
   * @description
   * add a chart type with provided series
   *
   * @param {string} type chart type to add to config
   * @param {Array<Object>} seriesPassed data series to populate chart with
   * @returns {ChartConfig} new config class
   */
  ChartConfig.prototype.addType = function addType(type, seriesPassed) {
    if (!isArray(seriesPassed) && !(0, _utils.isPlainObject)(seriesPassed)) {
      throw new TypeError('Series passed must be either a plain object or an array of plain objects.');
    }

    var series = isArray(seriesPassed) ? seriesPassed : [seriesPassed];
    var config = (0, _utils.getNewConfigWithSeries)(this.config, (0, _utils.getNewChartSeries)(series, type));

    return new ChartConfig(config, this.options);
  };

  /**
   * @function getType
   *
   * @description
   * get a specific type (or a list of types) from the series in the config
   *
   * @param {Array<string>|string} types the type(s) to select from the config
   * @returns {Array<Object>|Object|null} the matching type(s)
   */


  ChartConfig.prototype.getType = function getType(types) {
    var series = this.get('series');
    var length = series ? series.length : 0;

    if (!length) {
      return null;
    }

    return (0, _utils.isUndefined)(types) ? (0, _utils.getFirstIfOnly)(series) : (0, _utils.getSpecificSeries)(series, (0, _utils.getArrayOfItem)(types));
  };

  /**
   * @function removeType
   *
   * @description
   * remove an instance of a chart type, all instances, or all charts
   *
   * @param {Array<number|string>|string} [chartPath] chart type with optional index
   * @returns {ChartConfig} new config class
   */


  ChartConfig.prototype.removeType = function removeType(chartPath) {
    if ((0, _utils.isUndefined)(chartPath)) {
      return this.remove('series');
    }

    var _config$series = this.config.series,
        currentSeries = _config$series === undefined ? [] : _config$series;


    if (!currentSeries.length) {
      return this;
    }

    var _getPathArray = (0, _utils.getPathArray)(chartPath),
        chart = _getPathArray[0],
        indexString = _getPathArray[1];

    if ((0, _utils.isUndefined)(indexString)) {
      var series = currentSeries.filter(function (_ref) {
        var type = _ref.type;
        return type !== chart;
      });

      return this.set('series', series);
    }

    var chartIndices = (0, _utils.getMatchingChartIndices)(currentSeries, chart);
    var indexNumber = +indexString;
    var indexToRemove = chartIndices[(0, _utils.isNAN)(indexNumber) ? 0 : indexNumber];

    return (0, _utils.isUndefined)(indexToRemove) ? this : this.remove('series[' + indexToRemove + ']');
  };

  /**
   * @function updateType
   *
   * @description
   * update an existing type in the series of the config
   *
   * @param {Array<number|string>|string} chartPath chart type with optional index
   * @param {Object} seriesInstance value to update matching series instance to
   * @returns {ChartConfig} new config class
   */


  ChartConfig.prototype.updateType = function updateType(chartPath, seriesInstance) {
    var _config$series2 = this.config.series,
        currentSeries = _config$series2 === undefined ? [] : _config$series2;


    var length = currentSeries.length;

    if ((0, _utils.isUndefined)(chartPath) || !length) {
      return this;
    }

    if (!(0, _utils.isPlainObject)(seriesInstance)) {
      throw new TypeError('Series passed must be a plain object.');
    }

    var _getPathArray2 = (0, _utils.getPathArray)(chartPath),
        chart = _getPathArray2[0],
        indexString = _getPathArray2[1];

    var chartIndices = (0, _utils.getMatchingChartIndices)(currentSeries, chart);
    var indexNumber = +indexString;
    var indexToUpdate = chartIndices[(0, _utils.isNAN)(indexNumber) ? 0 : indexNumber];

    var key = 'series[' + indexToUpdate + ']';
    var existingSeries = this.get(key);

    if ((0, _utils.isUndefined)(existingSeries)) {
      return this;
    }

    var mergedSeries = (0, _utils.assign)({}, existingSeries, seriesInstance);
    var series = (0, _utils.getNewChartSeries)([mergedSeries], chart);

    return (0, _utils.isUndefined)(indexToUpdate) ? this : this.set(key, series[0]);
  };

  return ChartConfig;
}(_Config3.default);

_constants.CHART_CONVENIENCE_METHOD_NAMES.forEach(ChartConfig.addMethod(ChartConfig));

exports.default = ChartConfig;