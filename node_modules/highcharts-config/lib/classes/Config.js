'use strict';

exports.__esModule = true;

var _unchanged = require('unchanged');

var _utils = require('../utils');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } // external dependencies


// utils


/**
 * @module classes/Config
 */

/**
 * @private
 *
 * @class Config
 * @classdesc configuration object builder base class
 */
var Config = function () {
  /**
   * @function constructor
   *
   * @description
   * build the initial state of the config class
   *
   * @param {Object} [config={}] configuration to assign to the class
   * @param {Object} [options={}] additional options for instantiating the class
   * @returns {Config} configuration class
   */
  function Config() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Config);

    this.config = null;
    this.isValid = null;
    this.options = null;

    this.config = (0, _utils.getConfig)(Config, config);
    this.options = (0, _utils.assign)({}, options);

    var validate = this.options.validate;


    if ((0, _utils.isFunction)(validate)) {
      this.isValid = validate(this.config);
    }

    return this;
  }

  /**
   * @instance
   * @type {Object|null}
   */


  /**
   * @instance
   * @type {boolean|null}
   */


  /**
   * @instance
   * @type {Object|null}
   */


  /**
   * @function addConvenienceMethod
   * @static
   *
   * @description
   * add a convenience method to the constructor passed
   *
   * @param {function} Constructor constructor to assign method to prototype of
   * @param {Object} Constructor.prototype prototype to assign method to
   * @returns {function(string, (function|number)): (ChartConfig|OptionsConfig)} method to add convenience method
   */
  Config.addMethod = function addMethod(Constructor) {
    return function (methodName, method) {
      var methodToAssign = (0, _utils.isFunction)(method) ? (0, _utils.createAddMethodWrapper)(Constructor, method) : (0, _utils.createPropertyConvenienceMethod)(methodName);

      Object.defineProperty(Constructor.prototype, methodName, {
        configurable: false,
        enumerable: false,
        value: methodToAssign,
        writable: true
      });

      return Constructor;
    };
  };

  /**
   * @function clear
   *
   * @description
   * clear out the current config and start anew
   *
   * @returns {Config} new config class
   */


  Config.prototype.clear = function clear() {
    return new this.constructor({}, this.options);
  };

  /**
   * @function get
   *
   * @description
   * get a value from a path (top-level or nested) from the config
   *
   * @param {string} path path to retrieve from config
   * @returns {*} value at path
   */


  Config.prototype.get = function get(path) {
    return (0, _utils.isUndefined)(path) ? this.config : (0, _unchanged.get)(path, this.config);
  };

  /**
   * @function merge
   *
   * @description
   * merge the configs passed to form a new config
   *
   * @returns {Config} new config class
   */


  Config.prototype.merge = function merge() {
    for (var _len = arguments.length, otherConfigs = Array(_len), _key = 0; _key < _len; _key++) {
      otherConfigs[_key] = arguments[_key];
    }

    if (!otherConfigs.length) {
      return this;
    }

    var config = otherConfigs.reduce(function (newConfig, config) {
      return (0, _unchanged.merge)(null, newConfig, (0, _utils.getConfig)(Config, config));
    }, this.config);

    return new this.constructor(config, this.options);
  };

  /**
   * @function remove
   *
   * @description
   * remove item at path (top-level or nested) in the config
   *
   * @param {string} paths path to remove from config
   * @returns {Config} new config class
   */


  Config.prototype.remove = function remove(paths) {
    var keys = (0, _utils.getArrayOfItem)(paths);
    var config = (0, _utils.removeOrOmit)(keys, this.config);

    return new this.constructor(config, this.options);
  };

  /**
   * @function set
   *
   * @param {string} path path to set in config
   * @param {*} value value to assign to path
   * @returns {Config} new config class
   */


  Config.prototype.set = function set(path, value) {
    if ((0, _utils.isUndefined)(path)) {
      return this;
    }

    var config = (0, _utils.isPlainObject)(path) ? (0, _utils.getNewConfigFromObject)(this.config, path) : (0, _unchanged.set)(path, value, this.config);

    return new this.constructor(config, this.options);
  };

  /**
   * @function toString
   *
   * @description
   * return stringified config
   *
   * @returns {string} stringified config
   */


  Config.prototype.toString = function toString() {
    return JSON.stringify(this.config, null, 2);
  };

  return Config;
}();

exports.default = Config;