'use strict';

exports.__esModule = true;
exports.removeOrOmit = exports.getSpecificSeries = exports.getNewConfigWithSeries = exports.getNewConfigFromObject = exports.getNewChartSeries = exports.getMatchingChartIndices = exports.getFirstIfOnly = exports.isMixedChartType = exports.createPropertyConvenienceMethod = exports.canCombineChartTypes = exports.getNamespacedKey = exports.getDefaultSeries = exports.getConfig = exports.getPathArray = exports.getArrayOfItem = exports.createBuildConfig = exports.createAddMethodWrapper = exports.createAddMethod = exports.assign = exports.assignFallback = exports.isUndefined = exports.isPlainObject = exports.isNAN = exports.isFunction = undefined;

var _pathington = require('pathington');

var _unchanged = require('unchanged');

var _constants = require('./constants');

var isArray = Array.isArray;

// constants
// external dependencies

var getOwnPropertySymbols = Object.getOwnPropertySymbols,
    keys = Object.keys;
var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * @private
 *
 * @function isFunction
 *
 * @description
 * is the object passed a function
 *
 * @param {*} object the object to test
 * @returns {boolean} is the object a function
 */

var isFunction = exports.isFunction = function isFunction(object) {
  return typeof object === 'function';
};

/**
 * @private
 *
 * @function isNAN
 *
 * @description
 * is the object passed a NaN
 *
 * @param {*} object the object to test
 * @returns {boolean} is the object a NaN
 */
var isNAN = exports.isNAN = function isNAN(object) {
  return object !== object;
};

/**
 * @private
 *
 * @function isPlainObject
 *
 * @description
 * is the object passed a plain object
 *
 * @param {*} object the object to test
 * @returns {boolean} is the object a plain object
 */
var isPlainObject = exports.isPlainObject = function isPlainObject(object) {
  return !!object && object.constructor === Object;
};

/**
 * @private
 *
 * @function isUndefined
 *
 * @description
 * is the object passed undefined
 *
 * @param {*} object the object to test
 * @returns {boolean} is the object undefined
 */
var isUndefined = exports.isUndefined = function isUndefined(object) {
  return object === void 0;
};

/**
 * @function assignFallback
 *
 * @description
 * the fallback for when Object.assign() is unavailable
 *
 * @param {Object} target the target to assign to
 * @param  {...Object} sources the sources to assign to the target
 * @returns {Object} the assigned object
 */
var assignFallback = exports.assignFallback = function assignFallback(target) {
  for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    sources[_key - 1] = arguments[_key];
  }

  return sources.reduce(function (assigned, source) {
    if (!isPlainObject(source) && !isUndefined(source)) {
      return assigned;
    }

    for (var key in source) {
      if (hasOwnProperty.call(source, key)) {
        assigned[key] = source[key];
      }
    }

    if (typeof getOwnPropertySymbols !== 'function') {
      return assigned;
    }

    var symbols = getOwnPropertySymbols(source);

    return symbols.reduce(function (assignedWithSymbols, symbol) {
      assignedWithSymbols[symbol] = source[symbol];

      return assignedWithSymbols;
    }, assigned);
  }, target);
};

var assign = exports.assign = typeof Object.assign === 'function' ? Object.assign : assignFallback;

/**
 * @module utils
 */

/**
 * @private
 *
 * @function createAddMethod
 *
 * @description
 * create an add method function for specific constructor
 *
 * @param {function} Constructor constructor to assign method to
 * @param {function} Constructor.addMethod static method to add method to Constructor
 * @param {function} buildConfig main function, returned to allow chainability
 * @returns {function(string, function): function} add method to Constructor
 */
var createAddMethod = exports.createAddMethod = function createAddMethod(Constructor, buildConfig) {
  return function (methodName, method) {
    if (typeof method === 'function') {
      Constructor.addMethod(Constructor)(methodName, method);

      return buildConfig;
    }

    throw new TypeError('The second parameter needs to be a function.');
  };
};

/**
 * @private
 *
 * @function createAddMethodWrapper
 *
 * @description
 * create wrapper for method to ensure chainability
 *
 * @param {function} Constructor constructor to assign method to
 * @param {function} method method to execute in chain
 * @returns {function(): (ChartConfig|OptionsConfig)} new configuration class
 */
var createAddMethodWrapper = exports.createAddMethodWrapper = function createAddMethodWrapper(Constructor, method) {
  return function () {
    var result = method.call(this, this.config, this);
    var config = isPlainObject(result) ? result : this.config;

    return new Constructor(config, this.options);
  };
};

/**
 * @private
 *
 * @function createBuildConfig
 *
 * @description
 * create a buildConfig function specific to a constructor
 *
 * @param {function} Constructor constructor to call with config and options
 * @returns {function(Object, Object): (ChartConfig|OptionsConfig)}
 */
var createBuildConfig = exports.createBuildConfig = function createBuildConfig(Constructor) {
  return function () {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return new Constructor(config, options);
  };
};

/**
 * @private
 *
 * @function getArrayOfItem
 *
 * @description
 * get the array form of the item passed, if not already an array
 *
 * @param {*} item item to return in array form
 * @returns {Array<*>} array form of item
 */
var getArrayOfItem = exports.getArrayOfItem = function getArrayOfItem(item) {
  return isArray(item) ? item : [item];
};

/**
 * @private
 *
 * @function getPathArray
 *
 * @description
 * get the array form of the full path passed
 *
 * @param {Array<number|string>|string} path path to get array form of
 * @returns {Array<number|string>} array form of path
 */
var getPathArray = exports.getPathArray = function getPathArray(path) {
  return isArray(path) ? path : (0, _pathington.parse)(path);
};

/**
 * @private
 *
 * @function getConfig
 *
 * @description
 * curried function to get the config object based on if it is a Config or not
 *
 * @param {function} Config base config class
 * @param {Config|Object} config the object to test
 * @returns {Object} the config object
 */
var getConfig = exports.getConfig = function getConfig(Config, config) {
  return config instanceof Config ? config.get() : config;
};

/**
 * @private
 *
 * @function getDefaultSeries
 *
 * @description
 * get the series in the config or an empty array
 *
 * @param {Object} config config to retrieve series from
 * @returns {Array<Object>} series for the given config
 */
var getDefaultSeries = exports.getDefaultSeries = function getDefaultSeries(config) {
  return (0, _unchanged.getOr)([], ['series'], config);
};

/**
 * @private
 *
 * @function getKeyWithProperty
 *
 * @description
 * get the key namespaced
 *
 * @param {string} key key to namespace
 * @param {string} namespace namespace of key
 * @returns {string} complete key
 */
var getNamespacedKey = exports.getNamespacedKey = function getNamespacedKey(key, namespace) {
  return namespace + '.' + key;
};

/**
 * @private
 *
 * @function canCombineChartTypes
 *
 * @description
 * does the chart types in series allow for combination with other chart types
 *
 * @param {Array<Object>} series series data sets
 * @returns {boolean} does the series allow for combination of all the charts added
 */
var canCombineChartTypes = exports.canCombineChartTypes = function canCombineChartTypes(series) {
  return series.every(function (_ref) {
    var type = _ref.type;
    return !~_constants.CHARTS_UNABLE_TO_BE_MIXED.indexOf(type);
  });
};

/**
 * @private
 *
 * @function createPropertyConvenienceMethod
 *
 * @description
 * create a convenience property for the class
 *
 * @param {string} property property name
 * @returns {Function} method to assign to class at property
 */
var createPropertyConvenienceMethod = exports.createPropertyConvenienceMethod = function createPropertyConvenienceMethod(property) {
  return function (subKey, value) {
    var length = arguments.length;

    if (!length) {
      return this.get(property);
    }

    if (isPlainObject(subKey)) {
      var cleanArgs = keys(subKey).reduce(function (updatedObject, keyWithoutProperty) {
        updatedObject[getNamespacedKey(keyWithoutProperty, property)] = subKey[keyWithoutProperty];

        return updatedObject;
      }, {});

      return this.set(cleanArgs);
    }

    if (isArray(subKey)) {
      return this.set(property, subKey);
    }

    var key = getNamespacedKey(subKey, property);

    return length === 1 ? this.get(key) : this.set(key, value);
  };
};

/**
 * @private
 *
 * @function isMixedChartType
 *
 * @description
 * is the series a mixture of chart types or a single type
 *
 * @param {Array<Object>} series series data sets
 * @returns {boolean} are multiple chart types present
 */
var isMixedChartType = exports.isMixedChartType = function isMixedChartType(series) {
  if (!series.length) {
    return false;
  }

  var originalType = series[0].type;

  return series.slice(1).some(function (_ref2) {
    var type = _ref2.type;
    return type !== originalType;
  });
};

var getFirstIfOnly = exports.getFirstIfOnly = function getFirstIfOnly(items) {
  return items.length === 1 ? items[0] : items;
};

/**
 * @private
 *
 * @function getMatchingChartIndices
 *
 * @description
 * get the indices of the series where the type is the same as the chart passed
 *
 * @param {Array<Object>} series the series to get the indices from
 * @param {string} chart the chart to match indices of
 * @returns {Array<T>}
 */
var getMatchingChartIndices = exports.getMatchingChartIndices = function getMatchingChartIndices(series, chart) {
  return series.reduce(function (indices, _ref3, seriesIndex) {
    var type = _ref3.type;

    if (type === chart) {
      indices.push(seriesIndex);
    }

    return indices;
  }, []);
};

/**
 * @private
 *
 * @function getNewChartSeries
 *
 * @description
 * return the new series sets augmented with the chart type
 *
 * @param {Array<Object>} series series data sets
 * @param {string} type the type of chart
 * @returns {Array<Object>} series augmented with chart type
 */
var getNewChartSeries = exports.getNewChartSeries = function getNewChartSeries(series, type) {
  return series.map(function (seriesInstance) {
    return seriesInstance.type ? seriesInstance : assign({}, seriesInstance, { type: type });
  });
};

/**
 * @private
 *
 * @function getNewConfigFromObject
 *
 * @description
 * get a new configuration object based on iteratively setting new values at each key
 *
 * @param {Object} currentConfig configuration of the given instance
 * @param {Object} object key => value pairs to assign to the config
 * @returns {Object} new configuration object
 */
var getNewConfigFromObject = exports.getNewConfigFromObject = function getNewConfigFromObject(currentConfig, object) {
  return keys(object).reduce(function (config, key) {
    return (0, _unchanged.set)(key, object[key], config);
  }, currentConfig);
};

/**
 * @private
 *
 * @function getNewConfigWithSeries
 *
 * @description
 * get a new configuration with an series concatenated with existing series
 *
 * @param {Object} config current configuration of the given instance
 * @param {Array<Object>} series series data sets
 * @returns {Object} new configuration object
 */
var getNewConfigWithSeries = exports.getNewConfigWithSeries = function getNewConfigWithSeries(config, series) {
  var updatedSeries = getDefaultSeries(config).concat(series);

  if (isMixedChartType(updatedSeries) && !canCombineChartTypes(updatedSeries)) {
    throw new TypeError('Cannot combine these chart types.');
  }

  return (0, _unchanged.set)(['series'], updatedSeries, config);
};

/**
 * @private
 *
 * @function getSpecificSeries
 *
 * @description
 * get series that match the provided types
 *
 * @param {Array<Object>} series series to find matches for
 * @param {Array<string> }types types of series to filter by
 * @returns {Array<Object>|Object} matching series
 */
var getSpecificSeries = exports.getSpecificSeries = function getSpecificSeries(series, types) {
  var chart = void 0,
      indexOfChart = void 0,
      matches = void 0,
      match = void 0;

  var specificSeries = types.reduce(function (matchingSeries, type) {
    var _getPathArray = getPathArray(type);

    chart = _getPathArray[0];
    indexOfChart = _getPathArray[1];


    matches = series.filter(function (_ref4) {
      var seriesType = _ref4.type;
      return seriesType === chart;
    });

    if (isUndefined(indexOfChart)) {
      return matchingSeries.concat(matches);
    }

    match = matches[+indexOfChart];

    if (!isUndefined(match)) {
      matchingSeries.push(match);
    }

    return matchingSeries;
  }, []);

  return getFirstIfOnly(specificSeries);
};

/**
 * @private
 *
 * @function removeOrOmit
 *
 * @description
 * remove deeply-nested item from object based on whether it is an array or object
 *
 * @param {Array<string>} paths list of paths to remove
 * @param {Object} object object to remove values at paths from
 * @returns {Object} object with values at paths removed
 */
var removeOrOmit = exports.removeOrOmit = function removeOrOmit(paths, object) {
  return paths.reduce(function (updatedObject, path) {
    return (0, _unchanged.remove)(path, updatedObject);
  }, object);
};