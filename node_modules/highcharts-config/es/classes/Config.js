function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// external dependencies
import { get as _get, merge as _merge, set as _set } from 'unchanged';

// utils
import { assign, createAddMethodWrapper, createPropertyConvenienceMethod, getArrayOfItem, getConfig, getNewConfigFromObject, isFunction, isPlainObject, isUndefined, removeOrOmit } from '../utils';

/**
 * @module classes/Config
 */

/**
 * @private
 *
 * @class Config
 * @classdesc configuration object builder base class
 */

var Config = function () {
  /**
   * @function constructor
   *
   * @description
   * build the initial state of the config class
   *
   * @param {Object} [config={}] configuration to assign to the class
   * @param {Object} [options={}] additional options for instantiating the class
   * @returns {Config} configuration class
   */
  function Config() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Config);

    this.config = null;
    this.isValid = null;
    this.options = null;

    this.config = getConfig(Config, config);
    this.options = assign({}, options);

    var validate = this.options.validate;


    if (isFunction(validate)) {
      this.isValid = validate(this.config);
    }

    return this;
  }

  /**
   * @instance
   * @type {Object|null}
   */


  /**
   * @instance
   * @type {boolean|null}
   */


  /**
   * @instance
   * @type {Object|null}
   */


  /**
   * @function addConvenienceMethod
   * @static
   *
   * @description
   * add a convenience method to the constructor passed
   *
   * @param {function} Constructor constructor to assign method to prototype of
   * @param {Object} Constructor.prototype prototype to assign method to
   * @returns {function(string, (function|number)): (ChartConfig|OptionsConfig)} method to add convenience method
   */
  Config.addMethod = function addMethod(Constructor) {
    return function (methodName, method) {
      var methodToAssign = isFunction(method) ? createAddMethodWrapper(Constructor, method) : createPropertyConvenienceMethod(methodName);

      Object.defineProperty(Constructor.prototype, methodName, {
        configurable: false,
        enumerable: false,
        value: methodToAssign,
        writable: true
      });

      return Constructor;
    };
  };

  /**
   * @function clear
   *
   * @description
   * clear out the current config and start anew
   *
   * @returns {Config} new config class
   */


  Config.prototype.clear = function clear() {
    return new this.constructor({}, this.options);
  };

  /**
   * @function get
   *
   * @description
   * get a value from a path (top-level or nested) from the config
   *
   * @param {string} path path to retrieve from config
   * @returns {*} value at path
   */


  Config.prototype.get = function get(path) {
    return isUndefined(path) ? this.config : _get(path, this.config);
  };

  /**
   * @function merge
   *
   * @description
   * merge the configs passed to form a new config
   *
   * @returns {Config} new config class
   */


  Config.prototype.merge = function merge() {
    for (var _len = arguments.length, otherConfigs = Array(_len), _key = 0; _key < _len; _key++) {
      otherConfigs[_key] = arguments[_key];
    }

    if (!otherConfigs.length) {
      return this;
    }

    var config = otherConfigs.reduce(function (newConfig, config) {
      return _merge(null, newConfig, getConfig(Config, config));
    }, this.config);

    return new this.constructor(config, this.options);
  };

  /**
   * @function remove
   *
   * @description
   * remove item at path (top-level or nested) in the config
   *
   * @param {string} paths path to remove from config
   * @returns {Config} new config class
   */


  Config.prototype.remove = function remove(paths) {
    var keys = getArrayOfItem(paths);
    var config = removeOrOmit(keys, this.config);

    return new this.constructor(config, this.options);
  };

  /**
   * @function set
   *
   * @param {string} path path to set in config
   * @param {*} value value to assign to path
   * @returns {Config} new config class
   */


  Config.prototype.set = function set(path, value) {
    if (isUndefined(path)) {
      return this;
    }

    var config = isPlainObject(path) ? getNewConfigFromObject(this.config, path) : _set(path, value, this.config);

    return new this.constructor(config, this.options);
  };

  /**
   * @function toString
   *
   * @description
   * return stringified config
   *
   * @returns {string} stringified config
   */


  Config.prototype.toString = function toString() {
    return JSON.stringify(this.config, null, 2);
  };

  return Config;
}();

export default Config;