function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// classes
import Config from './Config';

// constants
import { CHART_CONVENIENCE_METHOD_NAMES } from '../constants';

// utils
import { assign, getArrayOfItem, getFirstIfOnly, getMatchingChartIndices, getNewChartSeries, getNewConfigWithSeries, getPathArray, getSpecificSeries, isNAN, isPlainObject, isUndefined } from '../utils';

/**
 * @module classes/ChartConfig
 */

var isArray = Array.isArray;

/**
 * @private
 *
 * @class ChartConfig
 * @classdesc configuration object builder for charts
 */

var ChartConfig = function (_Config) {
  _inherits(ChartConfig, _Config);

  function ChartConfig() {
    _classCallCheck(this, ChartConfig);

    return _possibleConstructorReturn(this, _Config.apply(this, arguments));
  }

  /**
   * @function addType
   *
   * @description
   * add a chart type with provided series
   *
   * @param {string} type chart type to add to config
   * @param {Array<Object>} seriesPassed data series to populate chart with
   * @returns {ChartConfig} new config class
   */
  ChartConfig.prototype.addType = function addType(type, seriesPassed) {
    if (!isArray(seriesPassed) && !isPlainObject(seriesPassed)) {
      throw new TypeError('Series passed must be either a plain object or an array of plain objects.');
    }

    var series = isArray(seriesPassed) ? seriesPassed : [seriesPassed];
    var config = getNewConfigWithSeries(this.config, getNewChartSeries(series, type));

    return new ChartConfig(config, this.options);
  };

  /**
   * @function getType
   *
   * @description
   * get a specific type (or a list of types) from the series in the config
   *
   * @param {Array<string>|string} types the type(s) to select from the config
   * @returns {Array<Object>|Object|null} the matching type(s)
   */


  ChartConfig.prototype.getType = function getType(types) {
    var series = this.get('series');
    var length = series ? series.length : 0;

    if (!length) {
      return null;
    }

    return isUndefined(types) ? getFirstIfOnly(series) : getSpecificSeries(series, getArrayOfItem(types));
  };

  /**
   * @function removeType
   *
   * @description
   * remove an instance of a chart type, all instances, or all charts
   *
   * @param {Array<number|string>|string} [chartPath] chart type with optional index
   * @returns {ChartConfig} new config class
   */


  ChartConfig.prototype.removeType = function removeType(chartPath) {
    if (isUndefined(chartPath)) {
      return this.remove('series');
    }

    var _config$series = this.config.series,
        currentSeries = _config$series === undefined ? [] : _config$series;


    if (!currentSeries.length) {
      return this;
    }

    var _getPathArray = getPathArray(chartPath),
        chart = _getPathArray[0],
        indexString = _getPathArray[1];

    if (isUndefined(indexString)) {
      var series = currentSeries.filter(function (_ref) {
        var type = _ref.type;
        return type !== chart;
      });

      return this.set('series', series);
    }

    var chartIndices = getMatchingChartIndices(currentSeries, chart);
    var indexNumber = +indexString;
    var indexToRemove = chartIndices[isNAN(indexNumber) ? 0 : indexNumber];

    return isUndefined(indexToRemove) ? this : this.remove('series[' + indexToRemove + ']');
  };

  /**
   * @function updateType
   *
   * @description
   * update an existing type in the series of the config
   *
   * @param {Array<number|string>|string} chartPath chart type with optional index
   * @param {Object} seriesInstance value to update matching series instance to
   * @returns {ChartConfig} new config class
   */


  ChartConfig.prototype.updateType = function updateType(chartPath, seriesInstance) {
    var _config$series2 = this.config.series,
        currentSeries = _config$series2 === undefined ? [] : _config$series2;


    var length = currentSeries.length;

    if (isUndefined(chartPath) || !length) {
      return this;
    }

    if (!isPlainObject(seriesInstance)) {
      throw new TypeError('Series passed must be a plain object.');
    }

    var _getPathArray2 = getPathArray(chartPath),
        chart = _getPathArray2[0],
        indexString = _getPathArray2[1];

    var chartIndices = getMatchingChartIndices(currentSeries, chart);
    var indexNumber = +indexString;
    var indexToUpdate = chartIndices[isNAN(indexNumber) ? 0 : indexNumber];

    var key = 'series[' + indexToUpdate + ']';
    var existingSeries = this.get(key);

    if (isUndefined(existingSeries)) {
      return this;
    }

    var mergedSeries = assign({}, existingSeries, seriesInstance);
    var series = getNewChartSeries([mergedSeries], chart);

    return isUndefined(indexToUpdate) ? this : this.set(key, series[0]);
  };

  return ChartConfig;
}(Config);

CHART_CONVENIENCE_METHOD_NAMES.forEach(ChartConfig.addMethod(ChartConfig));

export default ChartConfig;