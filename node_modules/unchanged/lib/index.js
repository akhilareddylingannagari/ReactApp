"use strict";

exports.__esModule = true;
exports.add = exports.transform = exports.set = exports.remove = exports.merge = exports.has = exports.getOr = exports.get = exports.call = exports.assign = void 0;

var _curriable = require("curriable");

exports.__ = _curriable.__;

var _utils = require("./utils");

// external dependencies
// utils

/**
 * @function assign
 *
 * @description
 * get the shallowly-merged object at path
 *
 * @param {Array<number|string>|null|number|string} path the path to match on the object
 * @param {Array<*>|Object} objectToAssign the object to merge
 * @param {Array<*>|Object} object the object to merge with
 * @returns {Array<*>|Object} the new merged object
 */
var assign = (0, _curriable.curry)(function (path, objectToAssign, object) {
  if (!(0, _utils.isCloneable)(object)) {
    return objectToAssign;
  }

  return (0, _utils.isEmptyPath)(path) ? (0, _utils.getMergedObject)(object, objectToAssign, false) : (0, _utils.getDeepClone)(path, object, function (ref, key) {
    ref[key] = (0, _utils.getMergedObject)(ref[key], objectToAssign, false);
  });
});
/**
 * @function call
 *
 * @description
 * call a nested method at the path requested with the parameters provided
 *
 * @param {Array<number|string>|null|number|string} path the path to get the value at
 * @param {Array<*>} parameters the parameters to call the method with
 * @param {Array<*>|Object} object the object to call the method from
 * @param {*} context the context to set as "this" in the function call
 */

exports.assign = assign;
var call = (0, _curriable.curry)(function (path, parameters, object, context) {
  if (context === void 0) {
    context = object;
  }

  return (0, _utils.isEmptyPath)(path) ? (0, _utils.callIfFunction)(object, context, parameters) : (0, _utils.callNestedProperty)(path, context, parameters, object);
}, // eslint-disable-next-line no-magic-numbers
3);
/**
 * @function get
 *
 * @description
 * get the value to the object at the path requested
 *
 * @param {Array<number|string>|null|number|string} path the path to get the value at
 * @param {Array<*>|Object} object the object to get the value from
 * @returns {*} the value requested
 */

exports.call = call;
var get = (0, _curriable.curry)(function (path, object) {
  return (0, _utils.isEmptyPath)(path) ? object : (0, _utils.getNestedProperty)(path, object);
});
/**
 * @function getOr
 *
 * @description
 * get the value to the object at the path requested, or noMatchValue if nothing
 * is there.
 *
 * @param {*} noMatchValue the fallback value if nothing is found at the given path
 * @param {Array<number|string>|null|number|string} path the path to get the value at
 * @param {Array<*>|Object} object the object to get the value from
 * @returns {*} the value requested
 */

exports.get = get;
var getOr = (0, _curriable.curry)(function (noMatchValue, path, object) {
  return (0, _utils.isEmptyPath)(path) ? object : (0, _utils.getNestedProperty)(path, object, noMatchValue);
});
/**
 * @function has
 *
 * @description
 * does the nested path exist on the object
 *
 * @param {Array<number|string>|null|number|string} path the path to match on the object
 * @param {Array<*>|Object} object the object to get the value from
 * @returns {boolean} does the path exist
 */

/* eslint-disable eqeqeq */

exports.getOr = getOr;
var has = (0, _curriable.curry)(function (path, object) {
  return (0, _utils.isEmptyPath)(path) ? object != null : (0, _utils.hasNestedProperty)(path, object);
});
/* eslint-enable */

/**
 * @function merge
 *
 * @description
 * get the deeply-merged object at path
 *
 * @param {Array<number|string>|null|number|string} path the path to match on the object
 * @param {Array<*>|Object} objectToMerge the object to merge
 * @param {Array<*>|Object} object the object to merge with
 * @returns {Array<*>|Object} the new merged object
 */

exports.has = has;
var merge = (0, _curriable.curry)(function (path, objectToMerge, object) {
  if (!(0, _utils.isCloneable)(object)) {
    return objectToMerge;
  }

  return (0, _utils.isEmptyPath)(path) ? (0, _utils.getMergedObject)(object, objectToMerge, true) : (0, _utils.getDeepClone)(path, object, function (ref, key) {
    ref[key] = (0, _utils.getMergedObject)(ref[key], objectToMerge, true);
  });
});
/**
 * @function removeobject with quoted keys
 *
 * @description
 * remove the value in the object at the path requested
 *
 * @param {Array<number|string>|number|string} path the path to remove the value at
 * @param {Array<*>|Object} object the object to remove the value from
 * @returns {Array<*>|Object} a new object with the same structure and the value removed
 */

exports.merge = merge;
var remove = (0, _curriable.curry)(function (path, object) {
  if ((0, _utils.isEmptyPath)(path)) {
    return (0, _utils.getNewEmptyObject)(object);
  }

  return (0, _utils.hasNestedProperty)(path, object) ? (0, _utils.getDeepClone)(path, object, function (ref, key) {
    if ((0, _utils.isArray)(ref)) {
      (0, _utils.splice)(ref, key);
    } else {
      delete ref[key];
    }
  }) : object;
});
/**
 * @function set
 *
 * @description
 * set the value in the object at the path requested
 *
 * @param {Array<number|string>|number|string} path the path to set the value at
 * @param {*} value the value to set
 * @param {Array<*>|Object} object the object to set the value in
 * @returns {Array<*>|Object} a new object with the same structure and the value assigned
 */

exports.remove = remove;
var set = (0, _curriable.curry)(function (path, value, object) {
  return (0, _utils.isEmptyPath)(path) ? value : (0, _utils.getDeepClone)(path, object, function (ref, key) {
    ref[key] = value;
  });
});
/**
 * @function transform
 *
 * @description
 * perform same operation as set, but using a callback function that receives
 * the value (and additional parameters, if provided) to get the value to set
 *
 * @param {Array<number|string>|number|string} path the path to set the value at
 * @param {function} fn the function to transform the retrieved value with
 * @param {Array<*>|Object} object the object to set the value in
 * @param {...Array<any>} extraArgs additional arguments to pass to the transform function
 * @returns {Array<*>|Object} a new object with the same structure and the value assigned
 */

exports.set = set;
var transform = (0, _curriable.curry)(function (path, fn, object) {
  for (var _len = arguments.length, extraArgs = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
    extraArgs[_key - 3] = arguments[_key];
  }

  return (0, _utils.isEmptyPath)(path) ? fn.apply(void 0, [object].concat(extraArgs)) : (0, _utils.getDeepClone)(path, object, function (ref, key) {
    return ref[key] = fn.apply(void 0, [ref[key]].concat(extraArgs));
  });
}, // eslint-disable-next-line no-magic-numbers
3);
/**
 * @function add
 *
 * @description
 * add the value to the object at the path requested
 *
 * @param {Array<number|string>|null|number|string} path the path to assign the value at
 * @param {*} value the value to assign
 * @param {Array<*>|Object} object the object to assignobject the value in
 * @returns {Array<*>|Object} a new object with the same structure and the value added
 */

exports.transform = transform;
var add = (0, _curriable.curry)(function (path, value, object) {
  var isPathEmpty = (0, _utils.isEmptyPath)(path);
  var valueAtPath = isPathEmpty ? object : (0, _utils.getNestedProperty)(path, object);
  var fullPath = (0, _utils.isArray)(valueAtPath) ? (0, _utils.isArray)(path) ? path.concat([valueAtPath.length]) : (isPathEmpty ? '' : path) + "[" + valueAtPath.length + "]" : path;
  return set(fullPath, value, object);
});
exports.add = add;