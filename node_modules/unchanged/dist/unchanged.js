(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('pathington'), require('curriable')) :
  typeof define === 'function' && define.amd ? define(['exports', 'pathington', 'curriable'], factory) :
  (factory((global.unchanged = {}),global.pathington,global.curriable));
}(this, (function (exports,pathington,curriable) { 'use strict';

  // external dependencies
  var O = Object;
  var create = O.create,
      getOwnPropertySymbols = O.getOwnPropertySymbols,
      getPrototypeOf = O.getPrototypeOf,
      keys = O.keys,
      propertyIsEnumerable = O.propertyIsEnumerable;
  var toStringObject = O.prototype.toString;
  var toStringFunction = Function.prototype.toString;
  /**
   * @constant {Symbol} REACT_ELEMENT
   */
  // eslint-disable-next-line no-magic-numbers

  var REACT_ELEMENT = typeof Symbol === 'function' && typeof Symbol.for === 'function' ? Symbol.for('react.element') : 0xeac7;
  /**
   * @constant {RegExp} FUNCTION_NAME
   */

  var FUNCTION_NAME = /^\s*function\s*([^\(]*)/i;
  /**
   * @function isArray
   */

  var isArray = Array.isArray;
  var cloneArray = function cloneArray(array) {
    var cloned = new array.constructor();

    for (var index = 0; index < array.length; index++) {
      cloned[index] = array[index];
    }

    return cloned;
  };
  /**
   * @function reduce
   *
   * @description
   * a slimmer, simpler reduce than native (for performance)
   *
   * @param {Array<any>} array the array to reduce
   * @param {function} fn the function to reduce each iteration of the array with
   * @param {any} initialValue the initial value of the reduction
   * @returns {any} the reduced array value
   */

  var reduce = function reduce(array, fn, initialValue) {
    var value = initialValue;

    for (var index = 0; index < array.length; index++) {
      value = fn(value, array[index]);
    }

    return value;
  };
  /**
   * @function getOwnProperties
   *
   * @description
   * get the own properties of an object, either keys or symbols
   *
   * @param {Object} object the object to get all keys and symbols of
   * @returns {Array<string|symbol>} the own properties of the object
   */

  var getOwnProperties = function getOwnProperties(object) {
    var ownSymbols = getOwnPropertySymbols(object);

    if (!ownSymbols.length) {
      return keys(object);
    }

    return keys(object).concat(reduce(ownSymbols, function (enumerableSymbols, symbol) {
      if (propertyIsEnumerable.call(object, symbol)) {
        enumerableSymbols.push(symbol);
      }

      return enumerableSymbols;
    }, []));
  };
  /**
   * @function assignFallback
   *
   * @description
   * a simple implementation of Object.assign
   *
   * @param {Object} target the target object
   * @param {Object} source the object to merge into target
   * @returns {Object} the shallowly-merged object
   */

  var assignFallback = function assignFallback(target, source) {
    if (!source) {
      return target;
    }

    return reduce(getOwnProperties(source), function (clonedObject, property) {
      clonedObject[property] = source[property];
      return clonedObject;
    }, Object(target));
  };
  var assign = typeof O.assign === 'function' ? O.assign : assignFallback;
  /**
   * @function isCloneable
   *
   * @description
   * can the object be cloned
   * 
   * - the object exists and is an object
   * - the object is not a Date or RegExp
   * - the object is not a React element
   *
   * @param {*} object the object to test
   * @returns {boolean} can the object be merged
   */

  var isCloneable = function isCloneable(object) {
    if (!object || typeof object !== 'object') {
      return false;
    }

    var type = toStringObject.call(object);
    return type !== '[object Date]' && type !== '[object RegExp]' && object.$$typeof !== REACT_ELEMENT;
  };
  /**
   * @function isGlobalConstructor
   *
   * @description
   * is the function passed a global constructor function
   *
   * @param {function} fn the function to test
   * @returns {boolean} is the function a global constructor
   */

  var isGlobalConstructor = function isGlobalConstructor(fn) {
    return typeof fn === 'function' && global[fn.name || toStringFunction.call(fn).split(FUNCTION_NAME)[1]] === fn;
  };
  /**
   * @function callIfFunction
   *
   * @description
   * call the object passed if it is a function and return its return, else return undefined
   *
   * @param {*} object the object to conditionally call if a function
   * @param {*} context the context to apply to the call
   * @param {Array<*>} parameters the parametesr to apply the function with
   * @returns {*} the restulf of the call or undefined
   */

  var callIfFunction = function callIfFunction(object, context, parameters) {
    return typeof object === 'function' ? object.apply(context, parameters) : void 0;
  };
  /**
   * @function getShallowClone
   *
   * @description
   * get a shallow clone of the value passed based on the type requested (maintaining prototype if possible)
   *
   * @param {Array<*>|Object} object the object to clone
   * @param {number|string} key the key to base the object type fromisReactElement(object) ||
   * @returns {Array<*>|Object} a shallow clone of the value
   */

  var getShallowClone = function getShallowClone(object) {
    if (object.constructor === O) {
      return assign({}, object);
    }

    if (isArray(object)) {
      return cloneArray(object);
    }

    return isGlobalConstructor(object.constructor) ? {} : assign(create(getPrototypeOf(object)), object);
  };
  /**
   * @function getNewEmptyChild
   *
   * @description
   * get a new empty child for the type of key provided
   *
   * @param {number|string} key the key to test
   * @returns {Array|Object} the empty child
   */

  var getNewEmptyChild = function getNewEmptyChild(key) {
    return typeof key === 'number' ? [] : {};
  };
  /**
   * @function getNewEmptyObject
   *
   * @description
   * get a new empty object for the type of key provided
   *
   * @param {Array|Object} object the object to get an empty value of
   * @returns {Array|Object} the empty object
   */

  var getNewEmptyObject = function getNewEmptyObject(object) {
    return isArray(object) ? [] : {};
  };
  /**
   * @function cloneIfPossible
   *
   * @description
   * clone the object passed if it is mergeable, else return itself
   *
   * @param {*} object he object to clone
   * @returns {*} the cloned object
   */

  var cloneIfPossible = function cloneIfPossible(object) {
    return isCloneable(object) ? getShallowClone(object) : object;
  };
  /**
   * @function getNewChildClone
   *
   * @description
   * get the shallow clone of the child when it is the correct type
   *
   * @param {Array<*>|Object} object the object to clone
   * @param {number|string} nextKey the key that the next object will be based from
   * @returns {Array<*>|Object} the clone of the key at object
   */

  var getNewChildClone = function getNewChildClone(object, nextKey) {
    return isCloneable(object) ? getShallowClone(object) : getNewEmptyChild(nextKey);
  };
  /**
   * @function getCoalescedValue
   *
   * @description
   * get the value if it is not undefined, else get the fallback
   *`
   * @param {any} value the main value to return
   * @param {any} fallbackValue the value to return if main is undefined
   * @returns {any} the coalesced value
   */

  var getCoalescedValue = function getCoalescedValue(value, fallbackValue) {
    return value === void 0 ? fallbackValue : value;
  };
  /**
   * @function onMatchAtPath
   *
   * @description
   * when there is a match for the path requested, call onMatch, else return the noMatchValue
   *
   * @param {Array<number|string>} path the path to find a match at
   * @param {Array<*>|Object} object the object to find the path in
   * @param {function} onMatch when a match is found, call this method
   * @param {boolean} shouldClone should the object be cloned
   * @param {*} noMatchValue when no match is found, return this value
   * @param {number} [index=0] the index of the key to process
   * @returns {*} either the return from onMatch or the noMatchValue
   */

  var onMatchAtPath = function onMatchAtPath(path, object, onMatch, shouldClone, noMatchValue, index) {
    if (index === void 0) {
      index = 0;
    }

    var key = path[index];
    var nextIndex = index + 1;

    if (nextIndex === path.length) {
      var result = object || shouldClone ? onMatch(object, key) : noMatchValue;
      return shouldClone ? object : result;
    }

    if (shouldClone) {
      object[key] = onMatchAtPath(path, getNewChildClone(object[key], path[nextIndex]), onMatch, shouldClone, noMatchValue, nextIndex);
      return object;
    }

    return object && object[key] ? onMatchAtPath(path, object[key], onMatch, shouldClone, noMatchValue, nextIndex) : noMatchValue;
  };
  /**
   * @function getMergedObject
   *
   * @description
   * get the objects merged into a new object
   *
   * @param {Array<*>|Object} object1 the object to merge into
   * @param {Array<*>|Object} object2 the object to merge
   * @param {boolean} isDeep is the object deeply merged
   * @returns {Array<*>|Object} the merged object
   */

  var getMergedObject = function getMergedObject(object1, object2, isDeep) {
    var isObject1Array = isArray(object1);

    if (isObject1Array !== isArray(object2) || !isCloneable(object1)) {
      return cloneIfPossible(object2);
    }

    if (isObject1Array) {
      return object1.concat(object2);
    }

    var target = object1.constructor === O || isGlobalConstructor(object1.constructor) ? {} : create(getPrototypeOf(object1));
    return reduce(getOwnProperties(object2), function (clone, key) {
      clone[key] = isDeep && isCloneable(object2[key]) ? getMergedObject(object1[key], object2[key], isDeep) : object2[key];
      return clone;
    }, assign(target, object1));
  };
  /**
   * @function getParsedPath
   *
   * @description
   * get the path array, either as-is if already an array, or parsed by pathington
   *
   * @param {Array<number|string>|number|string} path the path to parse
   * @returns {Array<number|string>} the parsed path
   */

  var getParsedPath = function getParsedPath(path) {
    return isArray(path) ? path : pathington.parse(path);
  };
  /**
   * @function callNestedProperty
   *
   * @description
   * parse the path passed and call the nested method at that path
   *
   * @param {Array<number|string>|number|string} path the path to retrieve values from the object
   * @param {*} context the context that the method is called with
   * @param {Array<*>} parameters the parameters to call the method with
   * @param {*} object the object to get values from
   * @returns {*} the retrieved values
   */

  var callNestedProperty = function callNestedProperty(path, context, parameters, object) {
    var parsedPath = getParsedPath(path);

    if (parsedPath.length === 1) {
      return object ? callIfFunction(object[parsedPath[0]], context, parameters) : void 0;
    }

    return onMatchAtPath(parsedPath, object, function (ref, key) {
      return callIfFunction(ref[key], context, parameters);
    });
  };
  /**
   * @function getNestedProperty
   *
   * @description
   * parse the path passed and get the nested property at that path
   *
   * @param {Array<number|string>|number|string} path the path to retrieve values from the object
   * @param {*} object the object to get values from
   * @param {*} noMatchValue an optional fallback value to be returned when the nested property isn't found
   * @returns {*} the retrieved values
   */

  var getNestedProperty = function getNestedProperty(path, object, noMatchValue) {
    var parsedPath = getParsedPath(path);

    if (parsedPath.length === 1) {
      return object ? getCoalescedValue(object[parsedPath[0]], noMatchValue) : noMatchValue;
    }

    return onMatchAtPath(parsedPath, object, function (ref, key) {
      return getCoalescedValue(ref[key], noMatchValue);
    }, false, noMatchValue);
  };
  /**
   * @function getDeepClone
   *
   * @description
   * parse the path passed and clone the object at that path
   *
   * @param {Array<number|string>|number|string} path the path to deeply modify the object on
   * @param {Array<*>|Object} object the objeisCurrentKeyArrayct to modify
   * @param {function} onMatch the callback to execute
   * @returns {Array<*>|Object} the clone object
   */

  var getDeepClone = function getDeepClone(path, object, onMatch) {
    var parsedPath = getParsedPath(path);
    var topLevelClone = isCloneable(object) ? getShallowClone(object) : getNewEmptyChild(parsedPath[0]);

    if (parsedPath.length === 1) {
      onMatch(topLevelClone, parsedPath[0]);
      return topLevelClone;
    }

    return onMatchAtPath(parsedPath, topLevelClone, onMatch, true);
  };
  /**
   * @function hasNestedProperty
   *
   * @description
   * parse the path passed and determine if a value at the path exists
   *
   * @param {Array<number|string>|number|string} path the path to retrieve values from the object
   * @param {*} object the object to get values from
   * @returns {boolean} does the nested path exist
   */

  var hasNestedProperty = function hasNestedProperty(path, object) {
    return getNestedProperty(path, object) !== void 0;
  };
  /* eslint-disable eqeqeq */

  /**
   * @function isEmptyPath
   *
   * @description
   * is the object passed an empty key value
   *
   * @param {*} object the object to test
   * @returns {boolean} is the object an empty key value
   */

  var isEmptyPath = function isEmptyPath(object) {
    return object == null || isArray(object) && !object.length;
  };
  /* eslint-enable */

  /**
   * @function splice
   *
   * @description
   * splice a single item from the array
   *
   * @param {Array<*>} array array to splice from
   * @param {number} splicedIndex index to splice at
   */

  var splice = function splice(array, splicedIndex) {
    if (array.length) {
      var length = array.length;
      var index = splicedIndex;

      while (index < length - 1) {
        array[index] = array[index + 1];
        ++index;
      }

      --array.length;
    }
  };

  // external dependencies
  /**
   * @function assign
   *
   * @description
   * get the shallowly-merged object at path
   *
   * @param {Array<number|string>|null|number|string} path the path to match on the object
   * @param {Array<*>|Object} objectToAssign the object to merge
   * @param {Array<*>|Object} object the object to merge with
   * @returns {Array<*>|Object} the new merged object
   */

  var assign$1 = curriable.curry(function (path, objectToAssign, object) {
    if (!isCloneable(object)) {
      return objectToAssign;
    }

    return isEmptyPath(path) ? getMergedObject(object, objectToAssign, false) : getDeepClone(path, object, function (ref, key) {
      ref[key] = getMergedObject(ref[key], objectToAssign, false);
    });
  });
  /**
   * @function call
   *
   * @description
   * call a nested method at the path requested with the parameters provided
   *
   * @param {Array<number|string>|null|number|string} path the path to get the value at
   * @param {Array<*>} parameters the parameters to call the method with
   * @param {Array<*>|Object} object the object to call the method from
   * @param {*} context the context to set as "this" in the function call
   */

  var call = curriable.curry(function (path, parameters, object, context) {
    if (context === void 0) {
      context = object;
    }

    return isEmptyPath(path) ? callIfFunction(object, context, parameters) : callNestedProperty(path, context, parameters, object);
  }, // eslint-disable-next-line no-magic-numbers
  3);
  /**
   * @function get
   *
   * @description
   * get the value to the object at the path requested
   *
   * @param {Array<number|string>|null|number|string} path the path to get the value at
   * @param {Array<*>|Object} object the object to get the value from
   * @returns {*} the value requested
   */

  var get = curriable.curry(function (path, object) {
    return isEmptyPath(path) ? object : getNestedProperty(path, object);
  });
  /**
   * @function getOr
   *
   * @description
   * get the value to the object at the path requested, or noMatchValue if nothing
   * is there.
   *
   * @param {*} noMatchValue the fallback value if nothing is found at the given path
   * @param {Array<number|string>|null|number|string} path the path to get the value at
   * @param {Array<*>|Object} object the object to get the value from
   * @returns {*} the value requested
   */

  var getOr = curriable.curry(function (noMatchValue, path, object) {
    return isEmptyPath(path) ? object : getNestedProperty(path, object, noMatchValue);
  });
  /**
   * @function has
   *
   * @description
   * does the nested path exist on the object
   *
   * @param {Array<number|string>|null|number|string} path the path to match on the object
   * @param {Array<*>|Object} object the object to get the value from
   * @returns {boolean} does the path exist
   */

  /* eslint-disable eqeqeq */

  var has = curriable.curry(function (path, object) {
    return isEmptyPath(path) ? object != null : hasNestedProperty(path, object);
  });
  /* eslint-enable */

  /**
   * @function merge
   *
   * @description
   * get the deeply-merged object at path
   *
   * @param {Array<number|string>|null|number|string} path the path to match on the object
   * @param {Array<*>|Object} objectToMerge the object to merge
   * @param {Array<*>|Object} object the object to merge with
   * @returns {Array<*>|Object} the new merged object
   */

  var merge = curriable.curry(function (path, objectToMerge, object) {
    if (!isCloneable(object)) {
      return objectToMerge;
    }

    return isEmptyPath(path) ? getMergedObject(object, objectToMerge, true) : getDeepClone(path, object, function (ref, key) {
      ref[key] = getMergedObject(ref[key], objectToMerge, true);
    });
  });
  /**
   * @function removeobject with quoted keys
   *
   * @description
   * remove the value in the object at the path requested
   *
   * @param {Array<number|string>|number|string} path the path to remove the value at
   * @param {Array<*>|Object} object the object to remove the value from
   * @returns {Array<*>|Object} a new object with the same structure and the value removed
   */

  var remove = curriable.curry(function (path, object) {
    if (isEmptyPath(path)) {
      return getNewEmptyObject(object);
    }

    return hasNestedProperty(path, object) ? getDeepClone(path, object, function (ref, key) {
      if (isArray(ref)) {
        splice(ref, key);
      } else {
        delete ref[key];
      }
    }) : object;
  });
  /**
   * @function set
   *
   * @description
   * set the value in the object at the path requested
   *
   * @param {Array<number|string>|number|string} path the path to set the value at
   * @param {*} value the value to set
   * @param {Array<*>|Object} object the object to set the value in
   * @returns {Array<*>|Object} a new object with the same structure and the value assigned
   */

  var set = curriable.curry(function (path, value, object) {
    return isEmptyPath(path) ? value : getDeepClone(path, object, function (ref, key) {
      ref[key] = value;
    });
  });
  /**
   * @function transform
   *
   * @description
   * perform same operation as set, but using a callback function that receives
   * the value (and additional parameters, if provided) to get the value to set
   *
   * @param {Array<number|string>|number|string} path the path to set the value at
   * @param {function} fn the function to transform the retrieved value with
   * @param {Array<*>|Object} object the object to set the value in
   * @param {...Array<any>} extraArgs additional arguments to pass to the transform function
   * @returns {Array<*>|Object} a new object with the same structure and the value assigned
   */

  var transform = curriable.curry(function (path, fn, object) {
    for (var _len = arguments.length, extraArgs = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      extraArgs[_key - 3] = arguments[_key];
    }

    return isEmptyPath(path) ? fn.apply(void 0, [object].concat(extraArgs)) : getDeepClone(path, object, function (ref, key) {
      return ref[key] = fn.apply(void 0, [ref[key]].concat(extraArgs));
    });
  }, // eslint-disable-next-line no-magic-numbers
  3);
  /**
   * @function add
   *
   * @description
   * add the value to the object at the path requested
   *
   * @param {Array<number|string>|null|number|string} path the path to assign the value at
   * @param {*} value the value to assign
   * @param {Array<*>|Object} object the object to assignobject the value in
   * @returns {Array<*>|Object} a new object with the same structure and the value added
   */

  var add = curriable.curry(function (path, value, object) {
    var isPathEmpty = isEmptyPath(path);
    var valueAtPath = isPathEmpty ? object : getNestedProperty(path, object);
    var fullPath = isArray(valueAtPath) ? isArray(path) ? path.concat([valueAtPath.length]) : (isPathEmpty ? '' : path) + "[" + valueAtPath.length + "]" : path;
    return set(fullPath, value, object);
  });

  exports.__ = curriable.__;
  exports.assign = assign$1;
  exports.call = call;
  exports.get = get;
  exports.getOr = getOr;
  exports.has = has;
  exports.merge = merge;
  exports.remove = remove;
  exports.set = set;
  exports.transform = transform;
  exports.add = add;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=unchanged.js.map
