{"version":3,"file":"unchanged.js","sources":["../src/utils.js","../src/index.js"],"sourcesContent":["// external dependencies\nimport {parse} from 'pathington';\n\nconst O = Object;\nconst {create, getOwnPropertySymbols, getPrototypeOf, keys, propertyIsEnumerable} = O;\nconst {toString: toStringObject} = O.prototype;\n\nconst {toString: toStringFunction} = Function.prototype;\n\n/**\n * @constant {Symbol} REACT_ELEMENT\n */\n// eslint-disable-next-line no-magic-numbers\nconst REACT_ELEMENT = typeof Symbol === 'function' && typeof Symbol.for === 'function' ? Symbol.for('react.element') : 0xeac7;\n\n/**\n * @constant {RegExp} FUNCTION_NAME\n */\nconst FUNCTION_NAME = /^\\s*function\\s*([^\\(]*)/i;\n\n/**\n * @function isArray\n */\nexport const {isArray} = Array;\n\n/**\n * @function cloneArray\n *\n * @description\n * shallowly clone an array\n *\n * @param {Array<any>} array the array to clone\n * @returns {Array<any>} the cloned array\n */\nexport const cloneArray = (array) => {\n  const cloned = new array.constructor();\n\n  for (let index = 0; index < array.length; index++) {\n    cloned[index] = array[index];\n  }\n\n  return cloned;\n};\n\n/**\n * @function reduce\n *\n * @description\n * a slimmer, simpler reduce than native (for performance)\n *\n * @param {Array<any>} array the array to reduce\n * @param {function} fn the function to reduce each iteration of the array with\n * @param {any} initialValue the initial value of the reduction\n * @returns {any} the reduced array value\n */\nexport const reduce = (array, fn, initialValue) => {\n  let value = initialValue;\n\n  for (let index = 0; index < array.length; index++) {\n    value = fn(value, array[index]);\n  }\n\n  return value;\n};\n\n/**\n * @function getOwnProperties\n *\n * @description\n * get the own properties of an object, either keys or symbols\n *\n * @param {Object} object the object to get all keys and symbols of\n * @returns {Array<string|symbol>} the own properties of the object\n */\nexport const getOwnProperties = (object) => {\n  const ownSymbols = getOwnPropertySymbols(object);\n\n  if (!ownSymbols.length) {\n    return keys(object);\n  }\n\n  return keys(object).concat(\n    reduce(\n      ownSymbols,\n      (enumerableSymbols, symbol) => {\n        if (propertyIsEnumerable.call(object, symbol)) {\n          enumerableSymbols.push(symbol);\n        }\n\n        return enumerableSymbols;\n      },\n      []\n    )\n  );\n};\n\n/**\n * @function assignFallback\n *\n * @description\n * a simple implementation of Object.assign\n *\n * @param {Object} target the target object\n * @param {Object} source the object to merge into target\n * @returns {Object} the shallowly-merged object\n */\nexport const assignFallback = (target, source) => {\n  if (!source) {\n    return target;\n  }\n\n  return reduce(\n    getOwnProperties(source),\n    (clonedObject, property) => {\n      clonedObject[property] = source[property];\n\n      return clonedObject;\n    },\n    Object(target)\n  );\n};\n\nconst assign = typeof O.assign === 'function' ? O.assign : assignFallback;\n\n/**\n * @function isCloneable\n *\n * @description\n * can the object be cloned\n * \n * - the object exists and is an object\n * - the object is not a Date or RegExp\n * - the object is not a React element\n *\n * @param {*} object the object to test\n * @returns {boolean} can the object be merged\n */\nexport const isCloneable = (object) => {\n  if (!object || typeof object !== 'object') {\n    return false;\n  }\n\n  const type = toStringObject.call(object);\n\n  return type !== '[object Date]' && type !== '[object RegExp]' && object.$$typeof !== REACT_ELEMENT;\n};\n\n/**\n * @function isGlobalConstructor\n *\n * @description\n * is the function passed a global constructor function\n *\n * @param {function} fn the function to test\n * @returns {boolean} is the function a global constructor\n */\nexport const isGlobalConstructor = (fn) =>\n  typeof fn === 'function' && global[fn.name || toStringFunction.call(fn).split(FUNCTION_NAME)[1]] === fn;\n\n/**\n * @function callIfFunction\n *\n * @description\n * call the object passed if it is a function and return its return, else return undefined\n *\n * @param {*} object the object to conditionally call if a function\n * @param {*} context the context to apply to the call\n * @param {Array<*>} parameters the parametesr to apply the function with\n * @returns {*} the restulf of the call or undefined\n */\nexport const callIfFunction = (object, context, parameters) =>\n  typeof object === 'function' ? object.apply(context, parameters) : void 0;\n\n/**\n * @function getShallowClone\n *\n * @description\n * get a shallow clone of the value passed based on the type requested (maintaining prototype if possible)\n *\n * @param {Array<*>|Object} object the object to clone\n * @param {number|string} key the key to base the object type fromisReactElement(object) ||\n * @returns {Array<*>|Object} a shallow clone of the value\n */\nexport const getShallowClone = (object) => {\n  if (object.constructor === O) {\n    return assign({}, object);\n  }\n\n  if (isArray(object)) {\n    return cloneArray(object);\n  }\n\n  return isGlobalConstructor(object.constructor) ? {} : assign(create(getPrototypeOf(object)), object);\n};\n\n/**\n * @function getNewEmptyChild\n *\n * @description\n * get a new empty child for the type of key provided\n *\n * @param {number|string} key the key to test\n * @returns {Array|Object} the empty child\n */\nexport const getNewEmptyChild = (key) => (typeof key === 'number' ? [] : {});\n\n/**\n * @function getNewEmptyObject\n *\n * @description\n * get a new empty object for the type of key provided\n *\n * @param {Array|Object} object the object to get an empty value of\n * @returns {Array|Object} the empty object\n */\nexport const getNewEmptyObject = (object) => (isArray(object) ? [] : {});\n\n/**\n * @function cloneIfPossible\n *\n * @description\n * clone the object passed if it is mergeable, else return itself\n *\n * @param {*} object he object to clone\n * @returns {*} the cloned object\n */\nexport const cloneIfPossible = (object) => (isCloneable(object) ? getShallowClone(object) : object);\n\n/**\n * @function getNewChildClone\n *\n * @description\n * get the shallow clone of the child when it is the correct type\n *\n * @param {Array<*>|Object} object the object to clone\n * @param {number|string} nextKey the key that the next object will be based from\n * @returns {Array<*>|Object} the clone of the key at object\n */\nexport const getNewChildClone = (object, nextKey) =>\n  isCloneable(object) ? getShallowClone(object) : getNewEmptyChild(nextKey);\n\n/**\n * @function getCoalescedValue\n *\n * @description\n * get the value if it is not undefined, else get the fallback\n *`\n * @param {any} value the main value to return\n * @param {any} fallbackValue the value to return if main is undefined\n * @returns {any} the coalesced value\n */\nexport const getCoalescedValue = (value, fallbackValue) => (value === void 0 ? fallbackValue : value);\n\n/**\n * @function onMatchAtPath\n *\n * @description\n * when there is a match for the path requested, call onMatch, else return the noMatchValue\n *\n * @param {Array<number|string>} path the path to find a match at\n * @param {Array<*>|Object} object the object to find the path in\n * @param {function} onMatch when a match is found, call this method\n * @param {boolean} shouldClone should the object be cloned\n * @param {*} noMatchValue when no match is found, return this value\n * @param {number} [index=0] the index of the key to process\n * @returns {*} either the return from onMatch or the noMatchValue\n */\nexport const onMatchAtPath = (path, object, onMatch, shouldClone, noMatchValue, index = 0) => {\n  const key = path[index];\n  const nextIndex = index + 1;\n\n  if (nextIndex === path.length) {\n    const result = object || shouldClone ? onMatch(object, key) : noMatchValue;\n\n    return shouldClone ? object : result;\n  }\n\n  if (shouldClone) {\n    object[key] = onMatchAtPath(\n      path,\n      getNewChildClone(object[key], path[nextIndex]),\n      onMatch,\n      shouldClone,\n      noMatchValue,\n      nextIndex\n    );\n\n    return object;\n  }\n\n  return object && object[key]\n    ? onMatchAtPath(path, object[key], onMatch, shouldClone, noMatchValue, nextIndex)\n    : noMatchValue;\n};\n\n/**\n * @function getMergedObject\n *\n * @description\n * get the objects merged into a new object\n *\n * @param {Array<*>|Object} object1 the object to merge into\n * @param {Array<*>|Object} object2 the object to merge\n * @param {boolean} isDeep is the object deeply merged\n * @returns {Array<*>|Object} the merged object\n */\nexport const getMergedObject = (object1, object2, isDeep) => {\n  const isObject1Array = isArray(object1);\n\n  if (isObject1Array !== isArray(object2) || !isCloneable(object1)) {\n    return cloneIfPossible(object2);\n  }\n\n  if (isObject1Array) {\n    return object1.concat(object2);\n  }\n\n  const target =\n    object1.constructor === O || isGlobalConstructor(object1.constructor) ? {} : create(getPrototypeOf(object1));\n\n  return reduce(\n    getOwnProperties(object2),\n    (clone, key) => {\n      clone[key] =\n        isDeep && isCloneable(object2[key]) ? getMergedObject(object1[key], object2[key], isDeep) : object2[key];\n\n      return clone;\n    },\n    assign(target, object1)\n  );\n};\n\n/**\n * @function getParsedPath\n *\n * @description\n * get the path array, either as-is if already an array, or parsed by pathington\n *\n * @param {Array<number|string>|number|string} path the path to parse\n * @returns {Array<number|string>} the parsed path\n */\nexport const getParsedPath = (path) => (isArray(path) ? path : parse(path));\n\n/**\n * @function callNestedProperty\n *\n * @description\n * parse the path passed and call the nested method at that path\n *\n * @param {Array<number|string>|number|string} path the path to retrieve values from the object\n * @param {*} context the context that the method is called with\n * @param {Array<*>} parameters the parameters to call the method with\n * @param {*} object the object to get values from\n * @returns {*} the retrieved values\n */\nexport const callNestedProperty = (path, context, parameters, object) => {\n  const parsedPath = getParsedPath(path);\n\n  if (parsedPath.length === 1) {\n    return object ? callIfFunction(object[parsedPath[0]], context, parameters) : void 0;\n  }\n\n  return onMatchAtPath(parsedPath, object, (ref, key) => callIfFunction(ref[key], context, parameters));\n};\n\n/**\n * @function getNestedProperty\n *\n * @description\n * parse the path passed and get the nested property at that path\n *\n * @param {Array<number|string>|number|string} path the path to retrieve values from the object\n * @param {*} object the object to get values from\n * @param {*} noMatchValue an optional fallback value to be returned when the nested property isn't found\n * @returns {*} the retrieved values\n */\nexport const getNestedProperty = (path, object, noMatchValue) => {\n  const parsedPath = getParsedPath(path);\n\n  if (parsedPath.length === 1) {\n    return object ? getCoalescedValue(object[parsedPath[0]], noMatchValue) : noMatchValue;\n  }\n\n  return onMatchAtPath(\n    parsedPath,\n    object,\n    (ref, key) => getCoalescedValue(ref[key], noMatchValue),\n    false,\n    noMatchValue\n  );\n};\n\n/**\n * @function getDeepClone\n *\n * @description\n * parse the path passed and clone the object at that path\n *\n * @param {Array<number|string>|number|string} path the path to deeply modify the object on\n * @param {Array<*>|Object} object the objeisCurrentKeyArrayct to modify\n * @param {function} onMatch the callback to execute\n * @returns {Array<*>|Object} the clone object\n */\nexport const getDeepClone = (path, object, onMatch) => {\n  const parsedPath = getParsedPath(path);\n  const topLevelClone = isCloneable(object) ? getShallowClone(object) : getNewEmptyChild(parsedPath[0]);\n\n  if (parsedPath.length === 1) {\n    onMatch(topLevelClone, parsedPath[0]);\n\n    return topLevelClone;\n  }\n\n  return onMatchAtPath(parsedPath, topLevelClone, onMatch, true);\n};\n\n/**\n * @function hasNestedProperty\n *\n * @description\n * parse the path passed and determine if a value at the path exists\n *\n * @param {Array<number|string>|number|string} path the path to retrieve values from the object\n * @param {*} object the object to get values from\n * @returns {boolean} does the nested path exist\n */\nexport const hasNestedProperty = (path, object) => getNestedProperty(path, object) !== void 0;\n\n/* eslint-disable eqeqeq */\n/**\n * @function isEmptyPath\n *\n * @description\n * is the object passed an empty key value\n *\n * @param {*} object the object to test\n * @returns {boolean} is the object an empty key value\n */\nexport const isEmptyPath = (object) => object == null || (isArray(object) && !object.length);\n/* eslint-enable */\n\n/**\n * @function splice\n *\n * @description\n * splice a single item from the array\n *\n * @param {Array<*>} array array to splice from\n * @param {number} splicedIndex index to splice at\n */\nexport const splice = (array, splicedIndex) => {\n  if (array.length) {\n    const {length} = array;\n\n    let index = splicedIndex;\n\n    while (index < length - 1) {\n      array[index] = array[index + 1];\n\n      ++index;\n    }\n\n    --array.length;\n  }\n};\n","// external dependencies\nimport {\n  __,\n  curry,\n} from 'curriable';\n\n// utils\nimport {\n  callIfFunction,\n  callNestedProperty,\n  getDeepClone,\n  getMergedObject,\n  getNestedProperty,\n  getNewEmptyObject,\n  hasNestedProperty,\n  isArray,\n  isCloneable,\n  isEmptyPath,\n  splice,\n} from './utils';\n\nexport {__};\n\n/**\n * @function assign\n *\n * @description\n * get the shallowly-merged object at path\n *\n * @param {Array<number|string>|null|number|string} path the path to match on the object\n * @param {Array<*>|Object} objectToAssign the object to merge\n * @param {Array<*>|Object} object the object to merge with\n * @returns {Array<*>|Object} the new merged object\n */\nexport const assign = curry((path, objectToAssign, object) => {\n  if (!isCloneable(object)) {\n    return objectToAssign;\n  }\n\n  return isEmptyPath(path)\n    ? getMergedObject(object, objectToAssign, false)\n    : getDeepClone(path, object, (ref, key) => {\n      ref[key] = getMergedObject(ref[key], objectToAssign, false);\n    });\n});\n\n/**\n * @function call\n *\n * @description\n * call a nested method at the path requested with the parameters provided\n *\n * @param {Array<number|string>|null|number|string} path the path to get the value at\n * @param {Array<*>} parameters the parameters to call the method with\n * @param {Array<*>|Object} object the object to call the method from\n * @param {*} context the context to set as \"this\" in the function call\n */\nexport const call = curry(\n  (path, parameters, object, context = object) =>\n    isEmptyPath(path)\n      ? callIfFunction(object, context, parameters)\n      : callNestedProperty(path, context, parameters, object),\n  // eslint-disable-next-line no-magic-numbers\n  3\n);\n\n/**\n * @function get\n *\n * @description\n * get the value to the object at the path requested\n *\n * @param {Array<number|string>|null|number|string} path the path to get the value at\n * @param {Array<*>|Object} object the object to get the value from\n * @returns {*} the value requested\n */\nexport const get = curry((path, object) => (isEmptyPath(path) ? object : getNestedProperty(path, object)));\n\n/**\n * @function getOr\n *\n * @description\n * get the value to the object at the path requested, or noMatchValue if nothing\n * is there.\n *\n * @param {*} noMatchValue the fallback value if nothing is found at the given path\n * @param {Array<number|string>|null|number|string} path the path to get the value at\n * @param {Array<*>|Object} object the object to get the value from\n * @returns {*} the value requested\n */\nexport const getOr = curry((noMatchValue, path, object) =>\n  isEmptyPath(path) ? object : getNestedProperty(path, object, noMatchValue)\n);\n\n/**\n * @function has\n *\n * @description\n * does the nested path exist on the object\n *\n * @param {Array<number|string>|null|number|string} path the path to match on the object\n * @param {Array<*>|Object} object the object to get the value from\n * @returns {boolean} does the path exist\n */\n/* eslint-disable eqeqeq */\nexport const has = curry((path, object) => (isEmptyPath(path) ? object != null : hasNestedProperty(path, object)));\n/* eslint-enable */\n\n/**\n * @function merge\n *\n * @description\n * get the deeply-merged object at path\n *\n * @param {Array<number|string>|null|number|string} path the path to match on the object\n * @param {Array<*>|Object} objectToMerge the object to merge\n * @param {Array<*>|Object} object the object to merge with\n * @returns {Array<*>|Object} the new merged object\n */\nexport const merge = curry((path, objectToMerge, object) => {\n  if (!isCloneable(object)) {\n    return objectToMerge;\n  }\n\n  return isEmptyPath(path)\n    ? getMergedObject(object, objectToMerge, true)\n    : getDeepClone(path, object, (ref, key) => {\n      ref[key] = getMergedObject(ref[key], objectToMerge, true);\n    });\n});\n\n/**\n * @function removeobject with quoted keys\n *\n * @description\n * remove the value in the object at the path requested\n *\n * @param {Array<number|string>|number|string} path the path to remove the value at\n * @param {Array<*>|Object} object the object to remove the value from\n * @returns {Array<*>|Object} a new object with the same structure and the value removed\n */\nexport const remove = curry((path, object) => {\n  if (isEmptyPath(path)) {\n    return getNewEmptyObject(object);\n  }\n\n  return hasNestedProperty(path, object)\n    ? getDeepClone(path, object, (ref, key) => {\n      if (isArray(ref)) {\n        splice(ref, key);\n      } else {\n        delete ref[key];\n      }\n    })\n    : object;\n});\n\n/**\n * @function set\n *\n * @description\n * set the value in the object at the path requested\n *\n * @param {Array<number|string>|number|string} path the path to set the value at\n * @param {*} value the value to set\n * @param {Array<*>|Object} object the object to set the value in\n * @returns {Array<*>|Object} a new object with the same structure and the value assigned\n */\nexport const set = curry((path, value, object) =>\n  isEmptyPath(path)\n    ? value\n    : getDeepClone(path, object, (ref, key) => {\n      ref[key] = value;\n    })\n);\n\n/**\n * @function transform\n *\n * @description\n * perform same operation as set, but using a callback function that receives\n * the value (and additional parameters, if provided) to get the value to set\n *\n * @param {Array<number|string>|number|string} path the path to set the value at\n * @param {function} fn the function to transform the retrieved value with\n * @param {Array<*>|Object} object the object to set the value in\n * @param {...Array<any>} extraArgs additional arguments to pass to the transform function\n * @returns {Array<*>|Object} a new object with the same structure and the value assigned\n */\nexport const transform = curry(\n  (path, fn, object, ...extraArgs) =>\n    isEmptyPath(path)\n      ? fn(object, ...extraArgs)\n      : getDeepClone(path, object, (ref, key) => (ref[key] = fn(ref[key], ...extraArgs))),\n  // eslint-disable-next-line no-magic-numbers\n  3\n);\n\n/**\n * @function add\n *\n * @description\n * add the value to the object at the path requested\n *\n * @param {Array<number|string>|null|number|string} path the path to assign the value at\n * @param {*} value the value to assign\n * @param {Array<*>|Object} object the object to assignobject the value in\n * @returns {Array<*>|Object} a new object with the same structure and the value added\n */\nexport const add = curry((path, value, object) => {\n  const isPathEmpty = isEmptyPath(path);\n  const valueAtPath = isPathEmpty ? object : getNestedProperty(path, object);\n  const fullPath = isArray(valueAtPath)\n    ? isArray(path)\n      ? path.concat([valueAtPath.length])\n      : `${isPathEmpty ? '' : path}[${valueAtPath.length}]`\n    : path;\n\n  return set(fullPath, value, object);\n});\n"],"names":["O","Object","create","getOwnPropertySymbols","getPrototypeOf","keys","propertyIsEnumerable","toStringObject","prototype","toString","toStringFunction","Function","REACT_ELEMENT","Symbol","for","FUNCTION_NAME","isArray","Array","cloneArray","array","cloned","constructor","index","length","reduce","fn","initialValue","value","getOwnProperties","object","ownSymbols","concat","enumerableSymbols","symbol","call","push","assignFallback","target","source","clonedObject","property","assign","isCloneable","type","$$typeof","isGlobalConstructor","global","name","split","callIfFunction","context","parameters","apply","getShallowClone","getNewEmptyChild","key","getNewEmptyObject","cloneIfPossible","getNewChildClone","nextKey","getCoalescedValue","fallbackValue","onMatchAtPath","path","onMatch","shouldClone","noMatchValue","nextIndex","result","getMergedObject","object1","object2","isDeep","isObject1Array","clone","getParsedPath","parse","callNestedProperty","parsedPath","ref","getNestedProperty","getDeepClone","topLevelClone","hasNestedProperty","isEmptyPath","splice","splicedIndex","curry","objectToAssign","get","getOr","has","merge","objectToMerge","remove","set","transform","extraArgs","add","isPathEmpty","valueAtPath","fullPath"],"mappings":"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"}